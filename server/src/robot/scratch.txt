// let target_x = target.x as f64;
//         let target_y = target.y as f64;
//         let target_z = target.z as f64;

//         // Calculate swing angle (rotation around base)
//         let swing_deg = (target_x / target_y).atan();
//         let lift_mm = target_y + self.dimensions.base_height;
//         let elbow_distance = (target_x.powi(2) + target_y.powi(2) + target_z.powi(2)).sqrt();
//         let angle = elbow_distance.powi(2) - elbow_distance.powi(2) - self.dimensions.w

//         // Calculate the horizontal distance from base to target
//         let horizontal_distance = (target_x.powi(2) + target_z.powi(2)).sqrt();

//         // Calculate vertical distance from base to target
//         let target_y = (target_y + self.dimensions.base_height).;
//         let vert_max = self.limits.lift_max as f64 / 1000.;
//         let vert_min = self.limits.lift_min as f64 / 1000.;
//         println!(
//             "are we valid (vertically)? {} - target is {} -  max limit is {} - min limit is {}",
//             target_y >= vert_min && target_y <= vert_max,
//             target_y,
//             vert_max,
//             vert_min
//         );
//         let vertical_distance = match target_y >= vert_min && target_y <= vert_max {
//             true => target_y,
//             false => {
//                 return Err(KinematicError::UnreachablePosition {
//                     x: target.x,
//                     y: target.y,
//                     z: target.z,
//                 })
//             }
//         };

//         // Calculate the distance in the plane of the arm
//         let arm_plane_distance = horizontal_distance - self.dimensions.wrist_extension_length;

//         // Get arm lengths
//         let l1 = self.dimensions.upper_arm_length;
//         let l2 = self.dimensions.lower_arm_length;

//         // Calculate the distance from shoulder to target in the arm plane
//         let d = (arm_plane_distance.powi(2) + vertical_distance.powi(2)).sqrt();

//         // Check if the target is reachable
//         // if d > (l1 + l2) || d < (l1 - l2).abs() {
//         //     return Err(KinematicError::UnreachablePosition {
//         //         x: target.x,
//         //         y: target.y,
//         //         z: target.z,
//         //     });
//         // }

//         // Calculate elbow angle using law of cosines
//         let elbow_cos = (l1.powi(2) + l2.powi(2) - d.powi(2)) / (2.0 * l1 * l2);
//         let elbow_deg = (elbow_cos.acos() * 180.0 / PI) as i64;

//         // Calculate shoulder angle
//         let alpha = (vertical_distance / arm_plane_distance).atan();
//         let beta = ((l2.powi(2) - l1.powi(2) - d.powi(2)) / (-2.0 * l1 * d)).acos();
//         let lift_deg = ((alpha + beta) * 180.0 / PI) as i64;

//         // Calculate wrist angle to keep gripper level
//         let wrist_deg = -(lift_deg + elbow_deg);

//         // Check if all angles are within limits
//         // if lift_deg < self.limits.lift_min || lift_deg > self.limits.lift_max ||
//         //    (self.limits.elbow_min != 0 && elbow_deg < self.limits.elbow_min) ||
//         //    (self.limits.elbow_max != 0 && elbow_deg > self.limits.elbow_max) ||
//         //    (self.limits.wrist_min != 0 && wrist_deg < self.limits.wrist_min) ||
//         //    (self.limits.wrist_max != 0 && wrist_deg > self.limits.wrist_max) {
//         //     return Err(KinematicError::UnreachablePosition {
//         //         x: target.x,
//         //         y: target.y,
//         //         z: target.z,
//         //     });
//         // }

//         Ok(CraneState {
//             swing_deg,
//             lift_mm: (vertical_distance * 1000.0) as i64,
//             elbow_deg,
//             wrist_deg,
//             gripper_mm: self.state.gripper_mm, // Keep current gripper position
//         })